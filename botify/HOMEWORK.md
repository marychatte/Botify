# Отчет о работе

### Первоначальные мысли и идеи (итоговая реализация в следующем абзаце) 

##### Что известно?

- Самый лучший рекомендер

  - *Sticky Artist*, который рекомендует треки того же исполнителя что и первый трек 

  - *Indexed*, который выдавает персонализированные рекомендации для пользователя

- Первый трек нравится пользователю 

- Важно разнообразие

- Длина сессии прямо зависит от длины прослушивания 

##### Что будем делать?

Изначально соберем для каждого пользователя список его первых треков и список самых понравившихся и непонравившихся треков (считаем, что трек понравился, если время его прослушивания >= 0.8, и не понравился, если <= 0.2). По данным у нас 50000 треков и 10000 пользователей, поэтому есть смысл делать user-based подход.

##### Каких пользователей считать похожими? 

Один из гиперпараметров - количество признаков, которыми описывать пользователя. Так как *Sticky Artist* оказался успешным рекомендером, то возникла идея описывать пользователя еще и его исполнителями, а не только треками, т.к. у нас нет мета-информации о самих треках.

##### Логика рекомендера:

Для каждого пользователя составим список похожих на него пользователей и будем рекомендовать трек, которые нравятся похожим на него пользователям.

Для этого попробовала обучить *lightfm* модель с дополнительной матрицей признаков пользователя и без нее. Для этого каждому пользователю сопоставим `k(3-5)` любимых треков, `k` нелюбимых треков, `k` любимых исполнителей и `k` нелюбимых исполнителей, потом было сделано *one-hot* преобразование числовых признаков. Так же с помощью *lightfm* для каждого пользователя составили список рекомендуемых ему песен. Тогда логика рекомендации следующего трека следующая: 

1. Есои похожий пользователь , тогда рекомендуемые треки этого пользователя
2. Если не нашлось, то любимые треки этого пользователя
3. Если не нашлось, то первые треки этого пользователя 
4. Иначе популярные треки

Однако, такой подход оказался совсем неудачным. Скорее всего это связано с тем, что модель довольно плохо обучается без знаний о признаках треков.

Т.к. у меня совсем не получилось заставить этот метод работать, то пришлось от него отказаться и попробовать что-то другое :(  

### Еще идеи:

1. Можно разделить пользователей на группы по похожести и описывать треки как вектор насколько он нравится конкретной группе: 

   ```mathematica
   (groups(1, 2), track -> [k1, k2] k1 = mean_time_in_group(1, track)), k2 = mean_time_in_group(2, track))
   ```

   Это позволило бы получить более хорошие эмбединги треков

2. Сейчас все изменения рекомендера происходят в оффлайне, учитывая рекомендации в онлайн можно было бы лучше понимать пользователей

3. Зная похожих пользователей, можно для этой группы вычислить рекомендации и выдавать каждому пользователю не его личные рекомендации, а рекомендации его группы пользователей



## Итоговая идея

Возьмем текущий рекомендер *Sticky Artist* и доработаем его:

1. Пользователю не обязаны нравится все треки этого исполнителя, поэтому начнем проверять рекомендуемые треки в принципе на те, что ему точно не нравятся

2. Текущий рекомендер совсем не отличается разнообразием, поэтому добавим к нашим трекам разнообразные другие, которые должны понравится пользователю, и как только `k` из них будут неудачными, мы будем "штрафовать" наш рекомендер и предлагать трек с помощью *Contextual* рекомендера



### Возникшие сложности

1. Данные для препроцессинга очень важны, модель намного хуже обучилась на данных с рандома

2. Не вышло прикрутить *users embeddings*, возможно, проблема в коде, возможно в данных

3. Поведение пользователя не всегда предсказуемо, по логам ему может нравиться трек x, но если в рекомендере порекомендовать, то пользователь послушает его с временем 0 



### Результат

Как и ожидалось, новый рекомендер получился лучше *Sticky Artist*, это видно по прикрепленным скриншотам



### Код:

Сбор данных - `jupyter/Preprocessing.ipynb`

Рекомендер - `botify/botify/recommenders/similar_users.py` (название осталось от первоначально идеи)

[image](https://github.com/marychatte/recsys-itmo-spring-2022/blob/master/botify/log_photo.png)